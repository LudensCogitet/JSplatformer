<canvas id="gameScreen"
        width=800
        height=600
        style="display: block; margin: 0 auto;" />
<script>
"use strict";
  let _gravity = 0.001;
  let _terminal_velocity = 0.8;

  function detectCollision(collider, collidee) {
    let collisionData = {
      x: {
        inside: collider.lx >= collidee.lx && collider.rx <= collidee.rx,
        left:   collider.lx <= collidee.rx && collider.rx >= collidee.rx,
        right:  collider.rx >= collidee.lx && collider.lx <= collidee.lx
      },
      y: {
        inside: collider.ty >= collidee.ty && collider.by <= collidee.by,
        top:    collider.ty <= collidee.by && collider.by >= collidee.by,
        bottom: collider.by >= collidee.ty && collider.ty <= collidee.ty
      }
    };

    let x = collisionData.x;
    let y = collisionData.y;

    if(!(x.inside || x.left || x.right) || !(y.inside || y.top || y.bottom))
      collisionData = false;

    return collisionData;
  }

  class Game {
    constructor(canvas) {
      this.gameScreen = document.getElementById(canvas);
      this.screenBuffer = this.gameScreen.getContext('2d');

      this.screenRect = this.gameScreen.getBoundingClientRect();

      this.objects = [];
      this.subjects = [];
      this.visible = [];

      this.mouseEventPos = {x: 0, y: 0};

      this.camera = { x: 0,
                      y: 0,
                      focusX: 100,
                      focusY: 50,
                      panningX: 0,
                      panningY: 0}

      this.player = null;

      this.lastDelta = 0;

      this.shifted = false;

      this.loop = this.loop.bind(this);
      this.start = this.start.bind(this);
      this.draw = this.draw.bind(this);

      this.gameScreen.addEventListener('mousemove',(event) => {
          this.mouseEventPos.x = event.x;
          this.mouseEventPos.y = event.y;
      });

      this.gameScreen.addEventListener('click', (event) => {
        let width = this.shifted ? 51 : 201;
        let height = this.shifted ? 201 : 51;
        new Platform(this.mousePos.x, this.mousePos.y, width, height, 'gray', game);
      });

      window.addEventListener('keydown', (event) => {
        if(event.key === 'Enter') { this.player.gravityOn = this.player.gravityOn ? false : true }
        if(event.key === 'Shift') { this.shifted = true }
      });

      window.addEventListener('keyup', (event) => {
        if(event.key === 'Shift') { this.shifted = false }
      });
    }

    get mousePos() {
      let x = (this.mouseEventPos.x - this.screenRect.left) + this.camera.x;
      let y = (this.mouseEventPos.y - this.screenRect.top) + this.camera.y;
      x -= x % 50;
      y -= y % 50;

      return {x: x,
              y: y};
    }

    get cameraRect() {
      return {lx: this.camera.x,
              ty: this.camera.y,
              rx: this.camera.x + this.gameScreen.width,
              by: this.camera.y + this.gameScreen.height};
    }

    adjustCamera(delta) {
      let xDiff = ((this.player.x + this.player.width/2) - this.camera.x) - (this.gameScreen.width/2);
      let yDiff = ((this.player.y + this.player.height/2) - this.camera.y) - (this.gameScreen.height/2);


      if(this.camera.panningX === 0) {
        if(xDiff > this.camera.focusX)  { this.camera.panningX = 1 }
        if(xDiff < -this.camera.focusX) { this.camera.panningX = -1 }
      }

      if(this.camera.panningY === 0) {
        if(yDiff > this.camera.focusY)  { this.camera.panningY = 1 }
        if(yDiff < -this.camera.focusY) { this.camera.panningY = -1 }
      }

      if((this.camera.panningX > 0 && this.player.dx > 0) || (this.camera.panningX < 0 && this.player.dx < 0)) {
        this.camera.x += this.player.dx * delta;
      }
      else { this.camera.panningX = 0 }

      if((this.camera.panningY > 0 && this.player.dy > 0) || (this.camera.panningY < 0 && this.player.dy < 0)) {
        this.camera.y += this.player.dy * delta;
      }
      else { this.camera.panningY = 0 }
    }

    start() {
      window.requestAnimationFrame(this.loop);
    }

    loop(timestamp) {
      let delta = timestamp - (this.lastDelta || timestamp);

      this.adjustCamera(delta);

      this.subjects.forEach(x => { x.act(delta) });

      this.screenBuffer.fillStyle = 'black';
      this.screenBuffer.fillRect(0,0,gameScreen.width,gameScreen.height);

      this.screenBuffer.fillStyle = 'rgba(0,200,0,0.5)';

      let width = this.shifted ? 51 : 201;
      let height = this.shifted ? 201 : 51;

      this.screenBuffer.fillRect(this.mousePos.x - this.camera.x, this.mousePos.y - this.camera.y, width, height);

      this.visible.forEach(x => { this.draw(x) });

      this.lastDelta = timestamp;
      window.requestAnimationFrame(this.loop);
    }

    draw(object) {
      if(!detectCollision(this.cameraRect, object.rect)) { return }

      let adjustedX = object.x - this.camera.x;
      let adjustedY = object.y - this.camera.y;

      this.screenBuffer.fillStyle = object.color;
      this.screenBuffer.fillRect(adjustedX, adjustedY, object.width, object.height);
    }
  }

  class GameObject {
    constructor(game) {
      this.game = game;
      this.game.objects.push(this);
    }
  }

  class Visible extends GameObject {
    constructor(x, y, width, height, color, game) {
      super(game);
      this.game.visible.push(this);
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.color = color;
    }

    draw(){
      this.game.draw(this)
    }

    get rect() {
      return {lx: this.x,
              rx: this.x + this.width,
              ty: this.y,
              by: this.y + this.height};
    }
  }

  class Guy extends Visible{
    constructor(x, y, color, keys, game) {
      super(x, y, Guy.size, Guy.size*2, color, game);
      this.game.subjects.push(this);
      this.game.player = this;
      this.state = "ungrounded"      // "ungrounded", "grounded"

      this.dx = 0;
      this.dy = 0;

      this.gravityOn = false;

      this.color = color;
      this.keys = keys;

      this.keyMap = { up: false,
                      down: false,
                      left: false,
                      right: false};

      window.addEventListener('keydown', (event) =>{
          if(event.key === this.keys.up)    { this.keyMap.up = true; }
          if(event.key === this.keys.down)  { this.keyMap.down = true; }
          if(event.key === this.keys.left)  { this.keyMap.left = true; }
          if(event.key === this.keys.right) { this.keyMap.right = true; }
      });

      window.addEventListener('keyup', (event) =>{
        if(event.key === this.keys.up)    { this.keyMap.up = false; }
        if(event.key === this.keys.down)  { this.keyMap.down = false; }
        if(event.key === this.keys.left)  { this.keyMap.left = false; }
        if(event.key === this.keys.right) { this.keyMap.right = false; }
      });
    }

    _input(delta) {
      if(this.keyMap.up)    if(this.state === "grounded") this.jump();

      if(this.keyMap.left)  {
        let accel = this.dx > 0 ? Guy.acceleration * Guy.hardStopMultiplier : Guy.acceleration;
        this.dx = this.dx > -Guy.maxSpeed ? this.dx - accel * delta : -Guy.maxSpeed;
      }

      if(this.keyMap.right) {
        let accel = this.dx < 0 ? Guy.acceleration * Guy.hardStopMultiplier : Guy.acceleration;
        this.dx = this.dx < Guy.maxSpeed ? this.dx + accel * delta : Guy.maxSpeed;
      }

      if(!this.keyMap.left && !this.keyMap.right && this.state === 'grounded') {
        if(this.dx < 0) {
          this.dx += Guy.decceleration * delta;
          if(this.dx > 0) this.dx = 0;
        }
        if(this.dx > 0) {
          this.dx -= Guy.decceleration * delta;
          if(this.dx < 0) this.dx = 0;
        }
      }
      if(this.keyMap.down) this.state = "grounded";
    }

    _collisions() {
      let didCollide = false;

      this.game.objects.forEach((object,i) => {
        if( object === this) return;
        let result = detectCollision(this.rect, object.rect);

        if(result) {
          didCollide = true;
          if(result.y.top) { this.y += (this.rect.ty - object.rect.by) }
          if(result.y.bottom) {
            this.y -= (this.rect.by - object.rect.ty);
            this.getGrounded();
          }
         if((result.x.left || result.x.right)&& !result.y.bottom) {
           this.x += this.dx;
           this.dx = 0;
         }
        }
      });

      if(!didCollide && this.state === "grounded") {
        this.state = "ungrounded";
      }
    }

    act(delta){
      this._input(delta);

      this.x += this.dx * delta;
      this.y += this.dy * delta;

      if(this.state !== "grounded" && this.gravityOn) {
        this.dy = this.dy < _terminal_velocity ? this.dy += _gravity * delta : _terminal_velocity;
      }

      this._collisions();
    }

    getGrounded() {
      this.state = 'grounded';
      this.dy = Guy.groundedFall;
    }

    jump() {
      this.dy = -Guy.jumpForce;
      this.state = "ungrounded";
    }
  }
  Guy.size = 20;
  Guy.acceleration = 0.001;
  Guy.decceleration = 0.0015;
  Guy.hardStopMultiplier = 3.5;
  Guy.maxSpeed = 0.4;
  Guy.jumpForce = 0.4;
  Guy.groundedFall = 0.00001;

  class Platform extends Visible {
    constructor(x, y, width, height, color, game) {
      super(x, y, width, height, color, game);
      this.solid = true;
    }
  }

let game = new Game('gameScreen');

let myGuy = new Guy(gameScreen.width/2, gameScreen.height/2,'blue',
                    {up: 'ArrowUp',
                    down: 'ArrowDown',
                    left: 'ArrowLeft',
                    right: 'ArrowRight',
                    cam_up: 'w',
                    cam_down: 's',
                    cam_left: 'a',
                    cam_right: 'd'}, game);

game.start();

</script>
